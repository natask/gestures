#!/usr/bin/env python3
# from tkinter import *
import subprocess, pathlib, shlex
import threading
import queue
import time
import os
import sys
import getConfig 
from math import tan
from math import pi
TOUCHPAD_CALIBRATION = 1 # scaling down for touchpad movements
TOUCHSCREEN_CALIBRATION = 2 # scaling down for touchscreen movements

DECISION = 450 # sufficient movement to make decision on direction
PINCH_DECISION = 160 #seems like x_cum and y_cum should got to around 0 if finges moved symetrically in or out  #sufficient momvent to make pinch

ANGLE = 70 #x/y angle cleance
CLEARANCE = 10#clearance for not intrepreting swipes between diagonal and horizontal or vertical

DEBOUNCE = 0.04  #sleep for 10 ms(now 40 ms), fastest tap around 25 ms, gotten from new_touch, touchpad data. in practice works well.
THRESHOLD = 150 # threashold to be considered a move, squared sum of x and y
PINCH_THRESHOLD = 100

REP_THRES = 0.2 #need to break this TIME before REP engage
REP = 350 # for 3 finger stuff
REP_3 = 150 # for 3 finger stuff
REP_4x= 450 # for 4 finger x, was having issue with horizontal swipes overstepping but vertical ones being perdicatable
REP_4 = 450 # for 4 finger stuff; repeat after this much x,y movement
PINCH_REP = 40

all_gestures = getConfig.get_conf(os.path.expanduser("~/.config/gestures.conf"))


# generic gesture worker
class Worker(threading.Thread):

    """ A worker thread that takes directory names from a queue, finds all
        files in them recursively and reports the result.

        Input is done by placing directory names (as strings) into the
        Queue passed in dir_q.

        Output is done by placing tuples into the Queue passed in result_q.
        Each tuple is (thread name, dirname, [list of files]).

        Ask the thread to stop by calling its join() method.
    """
    def __init__(self, q, gestures):
        super(Worker, self).__init__()
        self.q = q
        self.status = {} #slots :   {"id": status_dict[slot]["id"], "x" :x , "y" : y}
        self.status_dis = 0
        self.last_gesture_start = -1
        self.debounce = 0
        self.gestures = gestures
        self.gesture_queue = []
        self.rep_start = 0
        self.gesture = {"type": "", "total": {"x-cum": 0, "y-cum": 0, "moved": 0, "dis-cum": 0} , "slots" : {}} # keys: type, moved, slot (1-9), total ; slot and total keys: x-cum, y-cum, moved, dis-cum

    def run(self):
        # As long as we weren't asked to stop, try to take new tasks from the
        # queue. The tasks are taken with a blocking 'get', so no CPU
        # cycles are wasted while waiting.
        # Also, 'get' is given a timeout, so stoprequest is always checked,
        # even if there's nothing in the queue.
        while True:
            # get messages(dequeue from message queue) and do approperate action
            event = self.q.get(True)
            #print("def: ", event)
            if event["type"] == "finger_start":
                #print("finger_start")

                self.finger_start(event);
            if event["type"] == "finger_update":
                #print("finger_update")
                #print(event)
                self.finger_update(event);
            if event["type"] == "finger_remove":
                #print("finger_remove")
                self.finger_remove(event);

            # dequeue from gesture queue and execute after debounce times out
            if(len(self.gesture_queue) != 0 and float(event["time"]) - self.debounce >= DEBOUNCE):
                #print("executing")
                #print(self.gesture_queue)
                for gesture in self.gesture_queue:
                    #print(gesture)
                    try:
                        if(gesture):
                            subprocess.call(gesture);
                    except: 
                        print("error with:")
                        print("gesture = ", gesture)
                        print("gesture queue = ", self.gesture_queue)
                        print("gesture information = ", self.gesture)


                self.gesture_queue = [];



    def finger_start(self, event):
        """ append new finger to gesture.
        """
        # end gesture
        #self.gesture_end(event["time"]);
        ## restart debounce
        self.debounce = float(event["time"]);

        ## restart gesture params
        slots = self.gesture["slots"];
        self.gesture = {"type": "", "total": {"x-cum": 0, "y-cum": 0, "moved" : 0, "dis-cum": 0},  "slots" : {} } # keys: type, moved, slot (1-9), total ; slot and total keys: x-cum, y-cum
        for key in slots:
            self.gesture["slots"][key] = {"x-cum": 0, "y-cum": 0, "moved": 0};

        #  initiate state for finger
        slot = event["slot"];

        self.gesture["slots"][slot] = {};
        self.gesture["slots"][slot]["x-cum"] = 0
        #self.gesture["slots"][slot]["x-diff"] = 0
        #self.gesture["slots"][slot]["x"] = self.status[slot]["x"];

        self.gesture["slots"][slot]["y-cum"] = 0
        #self.gesture["slots"][slot]["y-diff"] = 0
        #self.gesture["slots"][slot]["y"] = self.status[slot]["y"];

        self.gesture["slots"][slot]["moved"] = 0

        self.update_status(slot, event[slot], 0); #need to wait until status updated before calcing max_dis
        max_dis =  self.max_distance();
        self.status_dis =  max_dis;
        #print(max_dis)
        #print(self.status);


    def finger_update(self, event):
        """ Update started gesture
        """
        # update state for updated finger
        slot = event["slot"];

        # gesture must be updated before status because need to capture difference between last and now
        self.gesture["slots"][slot]["x-cum"] +=  event[slot]["x"] - self.status[slot]["x"]
        #self.gesture["slots"][slot]["x-diff"] = event[slot]["x"] - self.status[slot]["x"]
        #self.gesture["slots"][slot]["x"] = self.status[slot]["x"];

        self.gesture["slots"][slot]["y-cum"] += event[slot]["y"] - self.status[slot]["y"]
        #self.gesture["slots"][slot]["y-diff"] = event[slot]["y"] - self.status[slot]["y"]
        #self.gesture["slots"][slot]["y"] = self.status[slot]["y"];

        self.gesture["total"]["x-cum"] += event[slot]["x"] - self.status[slot]["x"]
        self.gesture["total"]["y-cum"] += event[slot]["y"] - self.status[slot]["y"]

        max_dis =  self.max_distance();
        #print(max_dis);
        #print(self.status_dis);
        self.gesture["total"]["dis-cum"] += max_dis - self.status_dis;


        self.update_status(slot, event[slot],max_dis);

        #print(self.gesture["total"]);
        #print(self.status_dis);

        # pick which type of guesture is currenlty executing after all fingures have been verified
        no_slots = len(self.gesture["slots"]);
        if (not self.gesture["slots"][slot]["moved"]):
            self.gesture["slots"][slot]["moved"] = self.gesture["slots"][slot]["y-cum"] ** 2 + self.gesture["slots"][slot]["x-cum"] ** 2 > THRESHOLD
            self.gesture["total"]["moved"] += self.gesture["slots"][slot]["moved"];

        elif (not self.gesture["type"]):
            # pinch
            if(self.gesture["total"]["moved"] >= 1):# move out the pinch gesture sutff so that can do gestures when only one finger is moving
                x_cum = abs(self.gesture["total"]["x-cum"]);
                y_cum = abs(self.gesture["total"]["y-cum"]);
                dis_cum =  self.gesture["total"]["dis-cum"];

                #if (x_cum + y_cum > PINCH_DECISION):
                if(no_slots == 2):
                    #print(f"dis_cum = {dis_cum}")
                    #print(f"x_cum + y_cum = {x_cum + y_cum}")
                    if(x_cum + y_cum > PINCH_DECISION): #small hack to stop pinch from interspeting scrolling
                        self.gesture["type"] = "no_gesture";
                    elif(abs(dis_cum) > PINCH_THRESHOLD ):
                        if(dis_cum > 0): #pinch in
                            self.gesture["type"] += "pinch_i";
                            self.gesture_queue.extend(map(lambda x: shlex.split(x), self.gestures["pinch"]['2']['i']['start']));
                        else: #pinch out
                            self.gesture["type"] += "pinch_o";
                            self.gesture_queue.extend(map(lambda x: shlex.split(x), self.gestures["pinch"]['2']['o']['start']));
                        self.rep_start = float(event["time"]);

            # swipe            
            if(no_slots == self.gesture["total"]["moved"]):
                x_cum = abs(self.gesture["total"]["x-cum"]);
                y_cum = abs(self.gesture["total"]["y-cum"]);
                dis_cum =  self.gesture["total"]["dis-cum"];
                if (x_cum + y_cum > DECISION):
                    if(no_slots == 3):
                        if(y_cum <= x_cum * tan((90 - ANGLE) * pi/180) ):
                            self.gesture["type"] = "swipe_horizontal";
                            self.rep_start = float(event["time"]);
                            #print(self.gestures["swipe"]['3']['l']['start']);
                            if(self.gesture["total"]["x-cum"] <= 0) :
                                # self.gesture["type"] = "swipe_l";
                                self.gesture_queue.extend(map(lambda x: shlex.split(x), self.gestures["swipe"]['3']['l']['start']));
                            else :
                                # self.gesture["type"] = "swipe_r";
                                self.gesture_queue.extend(map(lambda x: shlex.split(x), self.gestures["swipe"]['3']['r']['start']));
                        elif (y_cum >= x_cum * tan(ANGLE * pi/180)):
                            self.gesture["type"] = "swipe_vertical";
                            if(self.gesture["total"]["y-cum"] <= 0) :
                                # self.gesture["type"] = "swipe_u";
                                self.gesture_queue.extend(map(lambda x: shlex.split(x), self.gestures["swipe"]['3']['u']['start']));
                            else :
                                # self.gesture["type"] = "swipe_d";
                                self.gesture_queue.extend(map(lambda x: shlex.split(x), self.gestures["swipe"]['3']['d']['start']));
                        elif(y_cum > x_cum * tan((90 - ANGLE - CLEARANCE) * pi/180) and y_cum < x_cum * tan((ANGLE + CLEARANCE) * pi/180)):
                            x_cum = self.gesture["total"]["x-cum"];
                            y_cum = self.gesture["total"]["y-cum"];
                            if(x_cum * y_cum > 0): #left up, right down
                                self.gesture["type"] = "swipe_diagonal_\\";   
                                if(x_cum <= 0 and y_cum < 0): #left up 
                                    # self.gesture["type"] = "swipe_lu";
                                    self.gesture_queue.extend(map(lambda x: shlex.split(x), self.gestures["swipe"]['3']['lu']['start']));

                                if(x_cum > 0 and y_cum >= 0): #right down
                                    # self.gesture["type"] = "swipe_rd";
                                    self.gesture_queue.extend(map(lambda x: shlex.split(x), self.gestures["swipe"]['3']['rd']['start']));

                            if(x_cum * y_cum < 0): #right up
                                self.gesture["type"] = "swipe_diagonal_//";   
                                if(x_cum >= 0 and y_cum < 0): #right up
                                    # self.gesture["type"] = "swipe_lu";
                                    self.gesture_queue.extend(map(lambda x: shlex.split(x), self.gestures["swipe"]['3']['ru']['start']));

                                if(x_cum < 0 and y_cum >= 0): #left down
                                    # self.gesture["type"] = "swipe_ld";
                                    self.gesture_queue.extend(map(lambda x: shlex.split(x), self.gestures["swipe"]['3']['ld']['start']));
                                
                                self.rep_start = float(event["time"]);

                        else: #fell under CLEARANCE
                            pass
                    if(no_slots == 4):
                        if(y_cum <= x_cum * tan((90 - ANGLE) * pi/180) or y_cum > x_cum * tan(ANGLE * pi/180) ):
                            self.gesture["type"] = "swipe_horizontal_vertical";
                            self.gesture_queue.append("evemu_do ctrl+alt down".split()); #xdotool was causing issue when esc was pressed beforehand
                            if (x_cum > y_cum):
                                if (self.gesture["total"]["x-cum"] >= 0):
                                    #self.gesture_queue.append("evemu_do Right".split()); #xdotool removed because was hanging on subprocess.call but not subprocess.Popen. p
                                    self.gesture_queue.extend(map(lambda x: shlex.split(x), self.gestures["swipe"]['4']['r']['start']));
                                else:
                                    self.gesture_queue.extend(map(lambda x: shlex.split(x), self.gestures["swipe"]['4']['l']['start']));
                            else:
                                if (self.gesture["total"]["y-cum"] >= 0):
                                    self.gesture_queue.extend(map(lambda x: shlex.split(x), self.gestures["swipe"]['4']['d']['start']));
                                else:
                                    self.gesture_queue.extend(map(lambda x: shlex.split(x), self.gestures["swipe"]['4']['u']['start']));
                            self.rep_start = float(event["time"]);
                        elif(y_cum > x_cum * tan((90 - ANGLE - CLEARANCE) * pi/180) and y_cum < x_cum * tan((ANGLE + CLEARANCE) * pi/180)):
                            x_cum = self.gesture["total"]["x-cum"];
                            y_cum = self.gesture["total"]["y-cum"];
                            if(x_cum * y_cum > 0): #left up, right down
                                self.gesture["type"] = "swipe_diagonal_\\";
                                if(x_cum <= 0 and y_cum < 0): #left up 
                                    self.gesture_queue.extend(map(lambda x: shlex.split(x), self.gestures["swipe"]['4']['lu']['start']));

                                if(x_cum > 0 and y_cum >= 0): #right down
                                    self.gesture_queue.extend(map(lambda x: shlex.split(x), self.gestures["swipe"]['4']['rd']['start']));

                            if(x_cum * y_cum < 0): #right up
                                self.gesture["type"] = "swipe_diagonal_//";
                                if(x_cum >= 0 and y_cum < 0): #right up
                                    self.gesture_queue.extend(map(lambda x: shlex.split(x), self.gestures["swipe"]['4']['ru']['start']));

                                if(x_cum < 0 and y_cum >= 0): #left down
                                    self.gesture_queue.extend(map(lambda x: shlex.split(x), self.gestures["swipe"]['4']['ld']['start']));

                                self.rep_start = float(event["time"]);

                    if(no_slots == 5):
                        if(y_cum <= x_cum * tan((90 - ANGLE) * pi/180) ):
                            self.gesture["type"] = "swipe_horizontal";
                        elif (y_cum > x_cum * tan(ANGLE * pi/180)):
                            self.gesture["type"] = "swipe_vertical";
                        elif(y_cum > x_cum * tan((90 - ANGLE - CLEARANCE) * pi/180) and y_cum < x_cum * tan((ANGLE + CLEARANCE) * pi/180)):
                            self.gesture["type"] = "swipe_diagonal";

                    # reset because don't want to trigger again in
                    if(self.gesture["type"]):
                        self.gesture["total"]["x-cum"] = 0;
                        self.gesture["total"]["y-cum"] = 0;
                        self.gesture["total"]["dis-cum"] = 0;
        # inqueue gesture to run
        else:
            if(float(event["time"]) - self.rep_start < REP_THRES): # to remove extra movement caused by movement before RE_THRES has been crossed
                self.gesture["total"]["x-cum"] = 0;
                self.gesture["total"]["y-cum"] = 0;
                self.gesture["total"]["dis-cum"] = 0;
            else:
                dis_cum =  self.gesture["total"]["dis-cum"];
                if(no_slots == 2):
                    if(self.gesture["type"] == "pinch_i"):
                       if(abs(dis_cum) > PINCH_REP):
                           if(dis_cum > 0): #pinch in
                               self.gesture_queue.extend(map(lambda x: shlex.split(x), self.gestures["pinch"]['2']['i']['update']['i']));
                           else: #pinch out
                               self.gesture_queue.extend(map(lambda x: shlex.split(x), self.gestures["pinch"]['2']['i']['update']['o']));

                           self.gesture["total"]["dis-cum"] = 0;
                    if(self.gesture["type"] == "pinch_o"):
                       if(abs(dis_cum) > PINCH_REP):
                           if(dis_cum > 0): #pinch in
                               self.gesture_queue.extend(map(lambda x: shlex.split(x), self.gestures["pinch"]['2']['o']['update']['i']));
                           else: #pinch out
                               self.gesture_queue.extend(map(lambda x: shlex.split(x), self.gestures["pinch"]['2']['o']['update']['o']));
                           self.gesture["total"]["dis-cum"] = 0;



                if(no_slots == 3):
                    if(self.gesture["type"] == "swipe_horizontal"):
                        # better to zero out after a gesture is triggered
                        if(self.gesture["total"]["x-cum"] >= REP_3):
                            self.gesture_queue.extend(map(lambda x: shlex.split(x), self.gestures["swipe"]['3']['l']['update']['r']));
                            # self.gesture_queue.append("evemu_do RIGHT".split());
                            #self.gesture["total"]["x-cum"] -= REP; #better to zero out
                            self.gesture["total"]["x-cum"] = 0
                        if(self.gesture["total"]["x-cum"] <= -REP_3):
                            self.gesture_queue.extend(map(lambda x: shlex.split(x), self.gestures["swipe"]['3']['l']['update']['l']));
                            # self.gesture_queue.append("evemu_do LEFT".split());
                            #self.gesture["total"]["x-cum"] += REP;
                            self.gesture["total"]["x-cum"] = 0;

                        # y is messured postive when moving down the touchpad
                        if(self.gesture["total"]["y-cum"] >= REP_3):
                            self.gesture_queue.extend(map(lambda x: shlex.split(x), self.gestures["swipe"]['3']['l']['update']['d']));
                            # self.gesture_queue.append("evemu_do DOWN".split());
                            #self.gesture["total"]["y-cum"] -= REP;
                            self.gesture["total"]["y-cum"] = 0;
                        if(self.gesture["total"]["y-cum"] <= -REP_3):
                            self.gesture_queue.extend(map(lambda x: shlex.split(x), self.gestures["swipe"]['3']['l']['update']['u']));
                            # self.gesture_queue.append("evemu_do UP".split());
                            #self.gesture["total"]["y-cum"] += REP;
                            self.gesture["total"]["y-cum"] = 0;

                    if(self.gesture["type"] == "swipe_diagonal_//"):
                        if(self.gesture["total"]["x-cum"] -  self.gesture["total"]["y-cum"] >= REP):
                            self.gesture_queue.extend(map(lambda x: shlex.split(x), self.gestures["swipe"]['3']['ld']['update']['ru']));
                            # self.gesture_queue.append("evemu_do Page_Down".split());
                            self.gesture["total"]["x-cum"] = 0; #better to zero out
                            self.gesture["total"]["y-cum"] = 0;

                        if(self.gesture["total"]["x-cum"] - self.gesture["total"]["y-cum"]  <=  -REP):
                            self.gesture_queue.extend(map(lambda x: shlex.split(x), self.gestures["swipe"]['3']['ld']['update']['ld']));
                            # self.gesture_queue.append("evemu_do Page_Up".split());
                            self.gesture["total"]["x-cum"] = 0; #better to zero out
                            self.gesture["total"]["y-cum"] = 0;
                            #self.gesture["total"]["y-cum"] = 0;

                if(no_slots == 4):
                    if(self.gesture["type"] == "swipe_horizontal_vertical"):
                        # better to zero out after a gesture is triggered
                        if(self.gesture["total"]["x-cum"] >= REP_4x):
                            self.gesture_queue.extend(map(lambda x: shlex.split(x), self.gestures["swipe"]['4']['l']['update']['r']));
                            # self.gesture_queue.append("evemu_do Right".split());
                            #self.gesture["total"]["x-cum"] -= REP; #better to zero out
                            self.gesture["total"]["x-cum"] = 0;
                            self.gesture["total"]["y-cum"] = 0;

                        if(self.gesture["total"]["x-cum"] <= -REP_4x):
                            self.gesture_queue.extend(map(lambda x: shlex.split(x), self.gestures["swipe"]['4']['l']['update']['l']));
                            # self.gesture_queue.append("evemu_do Left".split());
                            # self.gesture["total"]["x-cum"] += REP;
                            self.gesture["total"]["x-cum"] = 0;
                            self.gesture["total"]["y-cum"] = 0;

                        # y is messured postive when moving down the touchpad
                        if(self.gesture["total"]["y-cum"] >= REP_4):
                            self.gesture_queue.extend(map(lambda x: shlex.split(x), self.gestures["swipe"]['4']['l']['update']['d']));
                            # self.gesture_queue.append("evemu_do Down".split());
                            #self.gesture["total"]["y-cum"] -= REP;
                            self.gesture["total"]["y-cum"] = 0;
                            self.gesture["total"]["x-cum"] = 0;

                        if(self.gesture["total"]["y-cum"] <= -REP_4):
                            self.gesture_queue.extend(map(lambda x: shlex.split(x), self.gestures["swipe"]['4']['l']['update']['u']));
                            # self.gesture_queue.append("evemu_do Up".split());
                            #self.gesture["total"]["y-cum"] += REP;
                            self.gesture["total"]["y-cum"] = 0;
                            self.gesture["total"]["x-cum"] = 0;

                    if(self.gesture["type"] == "swipe_diagonal_//"):
                        if(self.gesture["total"]["x-cum"] -  self.gesture["total"]["y-cum"] >= REP):
                            self.gesture_queue.extend(map(lambda x: shlex.split(x), self.gestures["swipe"]['4']['ld']['update']['ru']));
                            # self.gesture_queue.append("evemu_do Right".split());
                            self.gesture["total"]["x-cum"] = 0; #better to zero out
                            self.gesture["total"]["y-cum"] = 0;

                        if(self.gesture["total"]["x-cum"] - self.gesture["total"]["y-cum"]  <=  -REP):
                            self.gesture_queue.extend(map(lambda x: shlex.split(x), self.gestures["swipe"]['4']['ld']['update']['ld']));
                            # self.gesture_queue.append("evemu_do Left".split());
                            self.gesture["total"]["x-cum"] = 0; #better to zero out
                            self.gesture["total"]["y-cum"] = 0;
                            #self.gesture["total"]["y-cum"] = 0;

        #print(self.gesture_queue)
        #print(self.gesture)


    def gesture_end(self, clock):
        """ end started gesture and reset gesture.
        """
        # signify end of a started gesture
        self.gesture_queue = [];
        x_cum = self.gesture["total"]["x-cum"];
        y_cum = self.gesture["total"]["y-cum"];
        no_slots = len(self.gesture["slots"]);
        #print(self.gesture);
        if (float(clock) - self.debounce >= DEBOUNCE):
            if(no_slots == 2):
                if(self.gesture["type"] == "pinch_i"):
                    #print(self.gestures["pinch"]['2']['i']['end']);
                    self.gesture_queue.extend(map(lambda x: shlex.split(x), self.gestures["pinch"]['2']['i']['end']));
                if(self.gesture["type"] == "pinch_o"):
                    #print(self.gestures["pinch"]['2']['o']['end']);
                    self.gesture_queue.extend(map(lambda x: shlex.split(x), self.gestures["pinch"]['2']['o']['end']));


            if(no_slots == 3):
                if (not self.gesture["type"]):
                    #print("3 finger tap");
                    self.gesture_queue.extend(map(lambda x: shlex.split(x), self.gestures["swipe"]['3']['t']));

                elif(self.gesture["type"] == "pinch_i"):
                    #print(self.gestures["pinch"]['3']['i']['end']);
                    self.gesture_queue.extend(map(lambda x: shlex.split(x), self.gestures["pinch"]['3']['i']['end']));
                elif(self.gesture["type"] == "pinch_o"):
                    #print(self.gestures["pinch"]['3']['o']['end']);
                    self.gesture_queue.extend(map(lambda x: shlex.split(x), self.gestures["pinch"]['3']['o']['end']));


                elif(self.gesture["type"] == "swipe_horizontal"):
                    #print("end 3 finger swipe_hor")

                    self.gesture_queue.extend(map(lambda x: shlex.split(x), self.gestures["swipe"]['3']['l']['end']));
                elif (self.gesture["type"] == "swipe_vertical"):
                    #print("swipe_ver")

                    self.gesture_queue.extend(map(lambda x: shlex.split(x), self.gestures["swipe"]['3']['u']['end']));

                elif(self.gesture["type"] == "swipe_diagonal_\\"):
                    if(x_cum < 0 and y_cum < 0): #left up
                        #print("left up")
                        self.gesture_queue.extend(map(lambda x: shlex.split(x), self.gestures["swipe"]['3']['lu']['end']));
                    if(x_cum >= 0 and y_cum >= 0): #right down
                        self.gesture_queue.extend(map(lambda x: shlex.split(x), self.gestures["swipe"]['3']['rd']['end']));

                elif(self.gesture["type"] == "swipe_diagonal_//"): # issue here if using x-cum and y-cum because they are wiped for interactive (not one-shot) devices
                        self.gesture_queue.extend(map(lambda x: shlex.split(x), self.gestures["swipe"]['3']['ld']['end']));

            if(no_slots == 4):
                if (not self.gesture["type"]):
                    #print("4 finger tap");
                    self.gesture_queue.extend(map(lambda x: shlex.split(x), self.gestures["swipe"]['4']['t']));


                elif(self.gesture["type"] == "pinch_i"):
                    #print(self.gestures["pinch"]['4']['i']['end']);
                    self.gesture_queue.extend(map(lambda x: shlex.split(x), self.gestures["pinch"]['4']['i']['end']));
                elif(self.gesture["type"] == "pinch_o"):
                    #print(self.gestures["pinch"]['4']['o']['end']);
                    self.gesture_queue.extend(map(lambda x: shlex.split(x), self.gestures["pinch"]['4']['o']['end']));


                elif (self.gesture["type"] == "swipe_horizontal_vertical"):
                    self.gesture_queue.extend(map(lambda x: shlex.split(x), self.gestures["swipe"]['4']['l']['end']));

                elif(self.gesture["type"] == "swipe_diagonal_\\"):
                    if(x_cum < 0 and y_cum < 0): #left up
                        #print("left up")
                        self.gesture_queue.extend(map(lambda x: shlex.split(x), self.gestures["swipe"]['4']['lu']['end']));
                    if(x_cum >= 0 and y_cum >= 0): #right down
                        self.gesture_queue.extend(map(lambda x: shlex.split(x), self.gestures["swipe"]['4']['rd']['end']));

                elif(self.gesture["type"] == "swipe_diagonal_//"): # issue here if using x-cum and y-cum because they are wiped for interactive (not one-shot) devices
                        self.gesture_queue.extend(map(lambda x: shlex.split(x), self.gestures["swipe"]['4']['ld']['end']));

            if(no_slots == 5):
                if (not self.gesture["type"]):
                    #print("5 finger tap");
                    self.gesture_queue.extend(map(lambda x: shlex.split(x), self.gestures["swipe"]['5']['t']));


                elif(self.gesture["type"] == "pinch_i"):
                    #print(self.gestures["pinch"]['5']['i']['end']);
                    self.gesture_queue.extend(map(lambda x: shlex.split(x), self.gestures["pinch"]['5']['i']['end']));
                elif(self.gesture["type"] == "pinch_o"):
                    #print(self.gestures["pinch"]['5']['o']['end']);
                    self.gesture_queue.extend(map(lambda x: shlex.split(x), self.gestures["pinch"]['5']['o']['end']));


                elif (self.gesture["type"] == "swipe_horizontal"):
                    #print("end 3 finger swipe_hor")

                    if(x_cum <= 0):
                        self.gesture_queue.extend(map(lambda x: shlex.split(x), self.gestures["swipe"]['5']['l']['end']));
                    else:
                        self.gesture_queue.extend(map(lambda x: shlex.split(x), self.gestures["swipe"]['5']['r']['end']));#'' for "" doesn't work as expected

                elif (self.gesture["type"] == "swipe_vertical"):
                    #print("swipe_ver")
                    if(y_cum <= 0):
                        self.gesture_queue.extend(map(lambda x: shlex.split(x), self.gestures["swipe"]['5']['u']['end']));
                    else:
                        self.gesture_queue.extend(map(lambda x: shlex.split(x), self.gestures["swipe"]['5']['d']['end']));

                elif(self.gesture["type"] == "swipe_diagonal"):
                    if(x_cum < 0 and y_cum < 0): #left up
                        #print("left up")
                        self.gesture_queue.extend(map(lambda x: shlex.split(x), self.gestures["swipe"]['5']['lu']['end']));
                    if(x_cum >= 0 and y_cum >= 0): #right down
                        self.gesture_queue.extend(map(lambda x: shlex.split(x), self.gestures["swipe"]['5']['rd']['end']));

                    if(x_cum < 0 and y_cum >= 0): #left down
                        self.gesture_queue.extend(map(lambda x: shlex.split(x), self.gestures["swipe"]['5']['ld']['end'])); #subprocess.Popen("orientation_swap".split(), cwd=pathlib.Path.home()); #hasn't shown value
                    if(x_cum >= 0 and y_cum < 0): #right up
                        self.gesture_queue.extend(map(lambda x: shlex.split(x), self.gestures["swipe"]['5']['ru']['end'])); #subprocess.Popen("orientation_swap".split(), cwd=pathlib.Path.home()); #hasn't shown value


        for gesture in self.gesture_queue:
            #print(gesture)
            try:
                if(gesture):
                    if (no_slots == 5):
                        subprocess.Popen(gesture);
                    else:
                        subprocess.call(gesture);
            except: 
                print("error with:")
                print("gesture = ", gesture)
                print("gesture queue = ", self.gesture_queue)
                print("gesture information = ", self.gesture)

        self.gesture_queue = [];

        # restart debounce
        self.debounce = float(clock);

        # restart gesture params
        slots = self.gesture["slots"];
        self.gesture = {"type": "", "total": {"x-cum": 0, "y-cum": 0, "moved" : 0, "dis-cum": 0}, "slots" : {} } # keys: type, moved, slot (1-9), total ; slot and total keys: x-cum, y-cum
        for key in slots:
            self.gesture["slots"][key] = {"x-cum": 0, "y-cum": 0, "moved": 0};



    def finger_remove(self, event):
        """remove status and gesture of removed finger.
        """

        # execute tap based gesture if any other gesture had not been started
        if(len(self.gesture_queue) == 0 and float(event["time"]) - self.debounce >= DEBOUNCE):
            # do tap gesture according to finger
            pass;

        # end gesture
        self.gesture_end(event["time"]);

        # update state
        removed_slot = event["removed_slot"];

        if(removed_slot in self.status ): #need this because not updating status when finger added (finger is on touchpad) but after finger starts (both x and y are valid)
            del self.status[removed_slot];
            del self.gesture["slots"][removed_slot];
        
        self.status_dis = self.max_distance();


    def update_status(self, slot, new_state, max_dis):
        self.status[slot] = new_state;
        self.status_dis = max_dis;
        #print(self.status);

    def max_distance(self):
        #return max distance between fingers
        max_dis = 0
        for fin1 in self.status:
            for fin2 in self.status:
                cur_dis = round(((self.status[fin1]["x"] - self.status[fin2]["x"])**2 + (self.status[fin1]["y"] - self.status[fin2]["y"])**2) ** (1/2))
                max_dis = max(max_dis, cur_dis)
        return max_dis;

# define and start gestures  

# N: Name="ipts 1B96:005E"
# P: Phys=heci3
# S: Sysfs=/devices/pci0000:00/0000:00:16.4/mei::3e8d0870-271a-4208-8eb5-9acb9402ae04:0F/0044:1B96:005E.0007/input/input32
# U: Uniq=
# H: Handlers=mouse4 event26 
# B: PROP=2
# B: EV=1b
# B: KEY=400 0 0 0 0 0
# B: ABS=32f3800000000003
# B: MSC=20
# --
# N: Name="Microsoft Surface Keyboard Touchpad"
# P: Phys=usb-0000:00:14.0-1.4/input0
# S: Sysfs=/devices/pci0000:00/0000:00:14.0/usb1/1-1/1-1.4/1-1.4:1.0/0003:045E:07CD.0012/input/input89
# U: Uniq=
# H: Handlers=mouse1 event6 
# B: PROP=5
# B: EV=1b
# B: KEY=e520 10000 0 0 0 0
# B: ABS=260800000000003
# B: MSC=20

# ORIENTATION AND AXIS MAJOR AND MINOR SEEM TO DEEL WITH HOW THE FINGER THAT IS CURRNETLY TOUCHING THE SCREENIS ORIENTED ON THE SCREEE, BELIVE ORIENTATION FIRES WHEN AXIS MAJOER BECOES LAEREE OR EBECOMES SMALLER THAN AXIS MINOR WBUT i HAVENT TESTED IT.
def main():
    device = "touchpad"
    result =  subprocess.getoutput(f"cat /proc/bus/input/devices | grep -iA 5 '{device}' | grep event").split()
    filter_result = list(filter(lambda x: x.find("event") != -1,result))
    for device_event in filter_result:
        device_event_index = device_event.find("event")
        device_event_name = device_event[device_event_index:]
        threading.Thread(target=test, args=[device_event_name, TOUCHPAD_CALIBRATION, device]).start() #change here to use evemu-record
    device = "touchscreen|IPTS touch"
    result =  subprocess.getoutput(f"cat /proc/bus/input/devices | grep -iEA 5 '{device}' | grep event").split()
    filter_result = list(filter(lambda x: x.find("event") != -1,result))
    if(not filter_result): #handle the case where touchscreen is not within device name in newer kernels
        device = "400 0 0 0 0 0"
        result =  subprocess.getoutput(f"cat /proc/bus/input/devices | grep -iB 5 '{device}' | grep event").split()
        filter_result = list(filter(lambda x: x.find("event") != -1,result))
        device = "touchscreen" 
    #print(filter_result)
    for device_event in filter_result:
       device_event_index = device_event.find("event")
       device_event_name = device_event[device_event_index:]
       threading.Thread(target=test, args=[device_event_name, TOUCHSCREEN_CALIBRATION, device]).start() #change here to use evemu-record
       #print(device_event_name, "j")

    return 1;

def test(device_event_name, factor, dev):
    #make sure to start with a single finger when the base re-attaches because slot and tracking id won't fire before position
    status_dict = {"0":{"id": -1, "x_updated": 0, "y_updated": 0}, "1":{"id": -1, "x_updated": 0, "y_updated": 0}, "2": {"id": -1, "x_updated": 0, "y_updated": 0}, "3":{"id": -1, "x_updated": 0, "y_updated": 0}, "4": {"id": -1, "x_updated": 0, "y_updated": 0}} #when the touchpad is restarted issues arise because (ABS_MT_TRACKING_ID), isn't called before x or y , this solve
    slot = "0"
    update = False

    # queue and worker
    q = queue.Queue()
    w = Worker(q, all_gestures[dev])
    w.start()

    # orientation, emplementing x and y swap takes a bit more of work
    orientation = subprocess.getoutput("orientation");
    #print(orientation);
    orientation_y = -1 if("inverted" == orientation or "right" == orientation) else 1;
    orientation_x = -1 if("inverted" == orientation or "left" == orientation) else 1;
    
    swap_x_y = True if("right" == orientation or "left" == orientation) else False;
    #print(swap_x_y)
    cmd = subprocess.Popen(["stdbuf", "-oL", "--","evtest",f"/dev/input/{device_event_name}"], stdout=subprocess.PIPE, bufsize=1, universal_newlines=True)
    for line in cmd.stdout:
        # implement debouncing and switching from one to another

        # removes startup printing
        line_arr = line.split()
        #sys.stderr.write(str(line_arr))
        #sys.stderr.write("\n")
        if (len(line_arr) < 2 or line_arr[1] != "time"):
            continue

        # get time,state, and event
        time = line_arr[2][:-1]
        state, event =  line_arr[-1],line_arr[-3]

        if "(ABS_MT_TRACKING_ID)," == event:
            if state == "-1":
                try:
                    del status_dict[slot]

                except:
                    del status_dict[slot]

                #notify worker to flush queue after finger is removed
                q.put({"type": "finger_remove", "removed_slot": slot,"time": time })
                #print(status_dict)
            else:
                status_dict[slot] = {"id": state, "x_updated": 0, "y_updated": 0}

                # debounce worker when finger is added
                # q.put({"type": "debounce"})
                #q.put({"type": "gesture_end", "time": time})


        if "(ABS_MT_SLOT)," == event:
            slot = state

        if "(ABS_MT_POSITION_X)," == event:
            if(swap_x_y):
               status_dict[slot]["y"] = float(state) / factor * orientation_y;
               status_dict[slot]["y_updated"] += 1;
            else: 
               status_dict[slot]["x"] = float(state) / factor * orientation_x;
               status_dict[slot]["x_updated"] += 1;
            update = True;

        if "(ABS_MT_POSITION_Y)," == event:
           if(swap_x_y):
               status_dict[slot]["x"] = float(state) / factor * orientation_x;
               status_dict[slot]["x_updated"] += 1;
           else:
               status_dict[slot]["y"] = float(state) / factor * orientation_y;
               status_dict[slot]["y_updated"] += 1;
           update = True;

        # if "(ABS_X)," == event:
        #     x1 = int(state)
        #     update = True
        #
        # if "(ABS_Y)," == event:
        #     y1 = int(state)
        #     update = True

        if event == "--------------" or event == "(MSC_TIMESTAMP),":
            continue

        if update:
            if status_dict[slot]["x_updated"] < 1 or status_dict[slot]["y_updated"] <  1:
                update = False
                continue

            x = status_dict[slot]["x"];
            y = status_dict[slot]["y"];
            finger_type = "";

            if ("objs" not in status_dict[slot]):
                status_dict[slot]["objs"] = True; # a way to call finger start the firt time a find is pressend down
                finger_type = "finger_start";
            else:
                finger_type = "finger_update";

            update = False;

            q.put({"type": finger_type, "slot": slot, "time": time, slot: {"id": status_dict[slot]["id"], "x" :x , "y" : y} }); #remember that these x,y have  been scaled down for touchscreen so that the gui can be seen

        #print(f"time = {time}, state = {state}, event = {event}")
if __name__ == "__main__":
    import sys
    # if call comes with arguments, pass only the first one. if it doesn't, start normal orientation operation
    # maybe implement builtin daemonization
    if len(sys.argv) > 1:
        main()
    else:
        subprocess.Popen(["daemonize", sys.argv[0], "execute"])



